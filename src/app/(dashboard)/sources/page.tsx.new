"use client"

import { useState, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Trash2, FileText, Globe, Plus, HelpCircle, Loader2, AlertCircle, Upload, File } from "lucide-react"
import { toast } from "sonner"
import { useParams, useRouter } from "next/navigation"

// Helper function to format bytes
const formatBytes = (bytes: number, decimals = 2) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  
  // Calculate the appropriate unit
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  // Format the number with the appropriate unit
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

type TrainingSource = {
  id: string;
  created_at: string;
  chatbot_id: string;
  source_type: string;
  content: string | null;
  url: string | null;
  file_path: string | null;
  file_name?: string | null;
  file_type?: string | null;
  status: string;
  size_kb: number;
  size_bytes?: number; // Keep for backward compatibility
};

export default function SourcesPage() {
  const router = useRouter();
  const params = useParams();
  const [activeTab, setActiveTab] = useState("qa");
  const [websiteUrl, setWebsiteUrl] = useState("");
  const [sitemapUrl, setSitemapUrl] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isTraining, setIsTraining] = useState(false);
  const [trainingSources, setTrainingSources] = useState<TrainingSource[]>([]);
  const [selectedChatbotId, setSelectedChatbotId] = useState<string>("");
  
  // Q&A state
  const [question, setQuestion] = useState("");
  const [answer, setAnswer] = useState("");
  
  // Text state
  const [textContent, setTextContent] = useState("");
  
  // Files state
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const dropZoneRef = useRef<HTMLDivElement>(null);
  
  // Fetch chatbot ID from URL or use default
  useEffect(() => {
    // Try to get chatbot ID from URL params
    const chatbotId = Array.isArray(params?.chatbotId) 
      ? params.chatbotId[0] 
      : params?.chatbotId;
    
    if (chatbotId) {
      setSelectedChatbotId(chatbotId);
      fetchTrainingSources(chatbotId);
    } else {
      // If no chatbot ID in URL, fetch the first chatbot
      fetchFirstChatbot();
    }
  }, [params]);
  
  // Switch to the appropriate tab when a source is added
  useEffect(() => {
    // If we're on the website tab but adding a Q&A or text source, switch tabs
    if (activeTab === "website" && (question || answer || textContent)) {
      if (question || answer) {
        setActiveTab("qa");
      } else if (textContent) {
        setActiveTab("text");
      }
    }
  }, [activeTab, question, answer, textContent]);
  
  const fetchFirstChatbot = async () => {
    try {
      const response = await fetch('/api/chatbot-config');
      if (!response.ok) throw new Error('Failed to fetch chatbot');
      
      const data = await response.json();
      // The API returns a single chatbot object directly, not an array
      if (data && data.id) {
        console.log('Found chatbot:', data.id);
        setSelectedChatbotId(data.id);
        fetchTrainingSources(data.id);
      } else {
        console.error('No chatbot found in response:', data);
        toast.error('No chatbot found for your account');
      }
    } catch (error) {
      console.error('Error fetching chatbot:', error);
      toast.error('Failed to load chatbot');
    }
  };
  
  const fetchTrainingSources = async (chatbotId: string) => {
    if (!chatbotId) return;
    
    try {
      setIsLoading(true);
      const response = await fetch(`/api/training-sources?chatbotId=${chatbotId}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch training sources');
      }
      
      const data = await response.json();
      setTrainingSources(data.sources || []);
      
      // Load the first text source content into the text editor if available
      const textSources = (data.sources || []).filter((source: TrainingSource) => source.source_type === 'text');
      if (textSources.length > 0 && textSources[0].content) {
        setTextContent(textSources[0].content);
      }
    } catch (error) {
      console.error('Error fetching training sources:', error);
      toast.error('Failed to load training sources');
    } finally {
      setIsLoading(false);
    }
  };
